{"version":3,"sources":["Components/Node.js","Algorithms/dijkstras.js","Algorithms/Prims Algorithm.js","Components/pathfind.js","App.js","index.js"],"names":["Node","props","classes","isStart","isEnd","isWall","className","id","row","col","onMouseOver","x","y","OnEnter","onMouseDown","OnDown","onMouseUp","OnUp","heuristic","a","b","Math","abs","dijkstra","startNode","endNode","openSet","closedSet","path","visitedNodes","push","leastIndex","i","length","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","error","shuffleArray","array","j","floor","random","getRandomItem","set","items","Array","from","Rmaze","grid","frontier","Set","visited","start","uniqueSet","addWallNeighbors","wallNeighbors","add","mazeStatus","WallSetup","Recurse","delete","curN","size","adj","rand","rows","round","window","innerHeight","makeRows","cols","innerWidth","makecols","hasStart","hasEnd","nodeStartRow","nodeStartCol","nodeEndRow","nodeEndCol","visualized","visualizing","Pathfind","useState","Grid","setGrid","useEffect","initializeGrid","Grid1","Spot","createSpot","this","undefined","connections","addNeighbors","isDown","setDown","wallUp","Reset","node","class","document","getElementById","gridwithNode","map","rowIndex","colIndex","onClick","Path","Visited","setTimeout","shortestPathNodes","shortestPath","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.df303d22.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  //console.log(props.isStart);\r\n  const classes = props.isStart\r\n    ? \"node-start\"\r\n    : props.isEnd\r\n    ? \"node-end\"\r\n    : props.isWall\r\n    ? \"wall\"\r\n    : \"\";\r\n  return (\r\n    <button\r\n      className={`Node ${classes}`}\r\n      id={`node-${props.row}-${props.col}`}\r\n      onMouseOver={(x, y) => props.OnEnter(props.row, props.col)}\r\n      onMouseDown={(x, y) => props.OnDown(props.row, props.col)}\r\n      onMouseUp={() => props.OnUp()}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","function dijkstra(startNode, endNode) {\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n    visitedNodes.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"no path\" };\r\n}\r\n\r\nfunction heuristic(a, b) {\r\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n  //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\r\n  return d;\r\n}\r\n\r\nexport default dijkstra;\r\n","function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    grid[(rand.x + 1 + current.x + 1) / 2 - 1][\r\n      (rand.y + 1 + current.y + 1) / 2 - 1\r\n    ].isWall = false;\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Node from \"./Node.js\";\r\nimport \"./Pathfind.css\";\r\nimport dijkstra from \"../Algorithms/dijkstras.js\";\r\nimport Rmaze from \"../Algorithms/Prims Algorithm.js\";\r\n\r\nfunction makeRows() {\r\n  let x = Math.round(window.innerHeight / 36);\r\n  if (x % 2 == 0) {\r\n    return x - 1;\r\n  } else {\r\n    return x;\r\n  }\r\n}\r\nfunction makecols() {\r\n  let x = Math.round(window.innerWidth / 29);\r\n  if (x % 2 == 0) {\r\n    return x - 1;\r\n  } else {\r\n    return x;\r\n  }\r\n}\r\nconst rows = makeRows();\r\nconst cols = makecols();\r\n\r\nlet hasStart = true;\r\nlet hasEnd = true;\r\nlet nodeStartRow = 2;\r\nlet nodeStartCol = 2;\r\nlet nodeEndRow = rows - 3;\r\nlet nodeEndCol = cols - 3;\r\nlet visualized = false;\r\nlet visualizing = false;\r\n\r\nconst Pathfind = () => {\r\n  const [Grid, setGrid] = useState([]);\r\n\r\n  useEffect(() => {\r\n    initializeGrid();\r\n  }, []);\r\n\r\n  const createSpot = (Grid) => {\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        Grid[i][j] = new Spot(i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  const initializeGrid = () => {\r\n    const Grid1 = new Array(rows);\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      Grid1[i] = new Array(cols);\r\n    }\r\n    createSpot(Grid1);\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  function Spot(i, j) {\r\n    this.x = i;\r\n    this.y = j;\r\n    this.f = 0;\r\n    this.h = 0;\r\n    this.g = 0;\r\n    this.mazeStatus = undefined;\r\n    this.wallNeighbors = [];\r\n    this.isWall = false;\r\n    this.connections = [];\r\n    this.addWallNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n\r\n      if (i > 1) {\r\n        this.wallNeighbors.push(grid[i - 2][j]);\r\n      }\r\n      if (i < rows - 2) {\r\n        this.wallNeighbors.push(grid[i + 2][j]);\r\n      }\r\n      if (j > 1) {\r\n        this.wallNeighbors.push(grid[i][j - 2]);\r\n      }\r\n      if (j < cols - 2) {\r\n        this.wallNeighbors.push(grid[i][j + 2]);\r\n      }\r\n    };\r\n\r\n    this.visited = false;\r\n    this.isStart = this.x === nodeStartRow && this.y === nodeStartCol;\r\n    this.isEnd = this.x === nodeEndRow && this.y === nodeEndCol;\r\n    this.neighbors = [];\r\n    this.previous = undefined;\r\n    this.addNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n      let rows = grid.length;\r\n      let cols = grid[1].length;\r\n\r\n      if (i > 0) {\r\n        this.neighbors.push(grid[i - 1][j]);\r\n      }\r\n      if (i < rows - 1) {\r\n        this.neighbors.push(grid[i + 1][j]);\r\n      }\r\n      if (j > 0) {\r\n        this.neighbors.push(grid[i][j - 1]);\r\n      }\r\n      if (j < cols - 1) {\r\n        this.neighbors.push(grid[i][j + 1]);\r\n      }\r\n\r\n      if (i > 0 && j > 0 && !(grid[i - 1][j].isWall && grid[i][j - 1].isWall)) {\r\n        this.neighbors.push(grid[i - 1][j - 1]);\r\n      }\r\n      if (\r\n        j < cols - 1 &&\r\n        i < rows - 1 &&\r\n        grid[i + 1][j].isWall == false &&\r\n        grid[i][j + 1].isWall == false\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j < cols - 1 &&\r\n        i > 0 &&\r\n        !(grid[i - 1][j].isWall && grid[i][j + 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i - 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j > 0 &&\r\n        i < rows - 1 &&\r\n        !(grid[i + 1][j].isWall && grid[i][j - 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j - 1]);\r\n      }\r\n    };\r\n  }\r\n\r\n  const addNeighbors = (grid) => {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        grid[i][j].addNeighbors(grid);\r\n      }\r\n    }\r\n  };\r\n\r\n  const [isDown, setDown] = useState(false);\r\n\r\n  const OnDown = (x, y) => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n    setDown(() => true);\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const OnUp = () => {\r\n    setDown(() => false);\r\n  };\r\n\r\n  const OnEnter = (x, y) => {\r\n    if (!isDown) {\r\n      return;\r\n    }\r\n\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const Reset = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        const node = Grid[i][j];\r\n        node.isWall = false;\r\n        node.neighbors = [];\r\n        node.class = node.isStart\r\n          ? \"node-start\"\r\n          : node.isEnd\r\n          ? \"node-end\"\r\n          : node.isWall\r\n          ? \"wall\"\r\n          : \"\";\r\n        document.getElementById(\r\n          `node-${node.x}-${node.y}`\r\n        ).className = `Node ${node.class}`;\r\n        node.f = 0;\r\n        node.h = 0;\r\n        node.g = 0;\r\n        node.visited = false;\r\n        node.neighbors = [];\r\n        node.previous = undefined;\r\n      }\r\n    }\r\n\r\n    visualized = false;\r\n    setGrid(() => Grid);\r\n  };\r\n  const wallUp = (x, y) => {\r\n    if (visualized) {\r\n      Reset();\r\n    }\r\n    let Grid1 = [...Grid];\r\n\r\n    if (!hasStart && !Grid1[x][y].isEnd) {\r\n      nodeStartRow = x;\r\n      nodeStartCol = y;\r\n      hasStart = true;\r\n      Grid1[x][y].isStart = true;\r\n    } else if (!hasEnd && !Grid1[x][y].isStart) {\r\n      nodeEndRow = x;\r\n      nodeEndCol = y;\r\n      hasEnd = true;\r\n      Grid1[x][y].isEnd = true;\r\n    } else if (Grid1[x][y].isEnd || Grid1[x][y].isStart || Grid1[x][y].isWall) {\r\n      if (Grid1[x][y].isEnd) {\r\n        nodeEndRow = null;\r\n        nodeEndCol = null;\r\n        hasEnd = false;\r\n        Grid1[x][y].isEnd = false;\r\n      }\r\n      if (Grid1[x][y].isStart) {\r\n        nodeStartRow = null;\r\n        nodeStartCol = null;\r\n        hasStart = false;\r\n        Grid1[x][y].isStart = false;\r\n      }\r\n      if (Grid1[x][y].isWall) {\r\n        Grid1[x][y].isWall = false;\r\n      }\r\n    } else {\r\n      Grid1[x][y].isWall = true;\r\n    }\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  const gridwithNode = (\r\n    <div>\r\n      {Grid.map((row, rowIndex) => {\r\n        return (\r\n          <div key={rowIndex} className=\"rowWrapper\">\r\n            {row.map((col, colIndex) => {\r\n              const { isStart, isEnd, isWall } = col;\r\n              return (\r\n                <Node\r\n                  key={colIndex}\r\n                  isStart={isStart}\r\n                  isEnd={isEnd}\r\n                  row={rowIndex}\r\n                  col={colIndex}\r\n                  OnEnter={OnEnter}\r\n                  OnDown={OnDown}\r\n                  isWall={isWall}\r\n                  OnUp={OnUp}\r\n                />\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  const shortestPath = (shortestPathNodes, startNode, endNode) => {\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPathNodes[i];\r\n        if (node !== startNode && node !== endNode) {\r\n          document.getElementById(`node-${node.x}-${node.y}`).className =\r\n            \"Node node-shortest\";\r\n        }\r\n      }, 5 * i);\r\n    }\r\n  };\r\n\r\n  function visualizePath() {\r\n    if (!hasStart || !hasEnd) {\r\n      return;\r\n    }\r\n    if (visualized) {\r\n      Reset();\r\n      return;\r\n    }\r\n    addNeighbors(Grid);\r\n    setGrid(() => Grid);\r\n\r\n    const startNode = Grid[nodeStartRow][nodeStartCol];\r\n    const endNode = Grid[nodeEndRow][nodeEndCol];\r\n\r\n    let path = dijkstra(startNode, endNode);\r\n\r\n    let Path = path.path;\r\n\r\n    let Visited = path.visitedNodes;\r\n\r\n    visualizing = true;\r\n\r\n    for (let i = 0; i <= Visited.length; i++) {\r\n      if (i === Visited.length) {\r\n        setTimeout(() => {\r\n          shortestPath(Path, startNode, endNode);\r\n          visualizing = false;\r\n        }, 15 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = Visited[i];\r\n          if (node !== startNode && node !== endNode) {\r\n            document.getElementById(`node-${node.x}-${node.y}`).className =\r\n              \"Node node-visited\";\r\n          }\r\n        }, 10 * i);\r\n      }\r\n    }\r\n    visualized = true;\r\n  }\r\n\r\n  const randomWalls = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    Reset();\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        if (Grid[i][j].isEnd || Grid[i][j].isStart) {\r\n        } else if (Math.random(1) < 0.2) {\r\n          Grid[i][j].isWall = true;\r\n          document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\r\n        } else {\r\n          Grid[i][j].isWall = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    setGrid(() => Grid);\r\n  };\r\n\r\n  function generateMaze() {\r\n    if (!hasStart || !hasEnd || visualizing) {\r\n      return;\r\n    }\r\n    Reset();\r\n    setGrid(() => Rmaze(Grid));\r\n    visualizing = true;\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      setTimeout(() => {\r\n        for (let j = 0; j < Grid[i].length; j++) {\r\n          setTimeout(() => {\r\n            const node = Grid[i][j];\r\n            if (!node.isStart && !node.endNode && node.isWall) {\r\n              document.getElementById(`node-${node.x}-${node.y}`).className =\r\n                \"Node wall\";\r\n            }\r\n            if (j == Grid[i].length - 1 && i == Grid.length - 1) {\r\n              visualizing = false;\r\n            }\r\n          }, 0 * j);\r\n        }\r\n      }, 0 * i);\r\n    }\r\n  }\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"header\">\r\n        <h1>Pathfinding Visualizer</h1>\r\n      </div>\r\n      <div className=\"header\">\r\n        <p>\r\n          click and drag to create walls - replace start and end nodes with\r\n          click\r\n        </p>\r\n      </div>\r\n      <div className=\"row\">\r\n        <div className=\"col-sm\">\r\n          <button onClick={visualizePath}>Vizualize Path (A*)</button>\r\n        </div>\r\n\r\n        <div className=\"col-sm\">\r\n          <button onClick={randomWalls}>Random Walls</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={Reset}>Reset</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={generateMaze}>\r\n            Generate Maze (Prim's Algorithm)\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      {gridwithNode}\r\n    </div>\r\n  );\r\n};\r\nexport default Pathfind;\r\n","import React from \"react\";\r\nimport Pathfind from \"./Components/pathfind.js\";\r\n\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <Pathfind />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <App />,\r\n\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}