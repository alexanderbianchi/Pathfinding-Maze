{"version":3,"sources":["Components/Node.js","Algorithms/dijkstras.js","Algorithms/Prims Algorithm.js","Components/pathfind.js","App.js","index.js"],"names":["Node","props","classes","isStart","isEnd","isWall","className","id","row","col","onMouseOver","x","y","OnEnter","onMouseDown","OnDown","onMouseUp","OnUp","heuristic","a","b","Math","abs","dijkstra","startNode","endNode","openSet","closedSet","path","visitedNodes","push","leastIndex","i","length","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","error","shuffleArray","array","j","floor","random","getRandomItem","set","items","Array","from","toV","Rmaze","grid","frontier","Set","visited","start","uniqueSet","node","addWallNeighbors","wallNeighbors","IsEnd","document","getElementById","add","mazeStatus","WallSetup","Recurse","delete","curN","size","adj","rand","setTimeout","rows","round","window","innerHeight","cols","innerWidth","hasStart","hasEnd","nodeStartRow","nodeStartCol","nodeEndRow","nodeEndCol","visualized","visualizing","Pathfind","useState","Grid","setGrid","useEffect","initializeGrid","Grid1","Spot","createSpot","this","undefined","connections","addNeighbors","isDown","setDown","wallUp","Reset","class","gridwithNode","map","rowIndex","colIndex","onClick","Path","Visited","shortestPathNodes","shortestPath","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.783489c8.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  //console.log(props.isStart);\r\n  const classes = props.isStart\r\n    ? \"node-start\"\r\n    : props.isEnd\r\n    ? \"node-end\"\r\n    : props.isWall\r\n    ? \"wall\"\r\n    : \"\";\r\n  return (\r\n    <button\r\n      className={`Node ${classes}`}\r\n      id={`node-${props.row}-${props.col}`}\r\n      onMouseOver={(x, y) => props.OnEnter(props.row, props.col)}\r\n      onMouseDown={(x, y) => props.OnDown(props.row, props.col)}\r\n      onMouseUp={() => props.OnUp()}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","function dijkstra(startNode, endNode) {\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n    visitedNodes.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"no path\" };\r\n}\r\n\r\nfunction heuristic(a, b) {\r\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n  //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\r\n  return d;\r\n}\r\n\r\nexport default dijkstra;\r\n","function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\nlet toV = [];\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        let node = grid[i][j];\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n\r\n          if (!node.isStart && !node.IsEnd && node.isWall) {\r\n            document.getElementById(`node-${node.x}-${node.y}`).className =\r\n              \"Node\";\r\n          }\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n\r\n            if (!node.isStart && !node.IsEnd && node.isWall) {\r\n              document.getElementById(`node-${node.x}-${node.y}`).className =\r\n                \"Node wall\";\r\n            }\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    let x = (rand.x + 1 + current.x + 1) / 2 - 1;\r\n    let y = (rand.y + 1 + current.y + 1) / 2 - 1;\r\n    grid[x][y].isWall = false;\r\n\r\n    toV.push([x, y]);\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  for (let i = 0; i < toV.length; i++) {\r\n    let x = toV[i][0];\r\n    let y = toV[i][1];\r\n    let node = grid[x][y];\r\n    setTimeout(() => {\r\n      if (!node.isStart && !node.IsEnd && !node.isWall) {\r\n        document.getElementById(`node-${node.x}-${node.y}`).className = \"Node\";\r\n      }\r\n    }, 70 * i);\r\n  }\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Node from \"./Node.js\";\r\nimport \"./Pathfind.css\";\r\nimport dijkstra from \"../Algorithms/dijkstras.js\";\r\nimport Rmaze from \"../Algorithms/Prims Algorithm.js\";\r\n\r\nconst rows = Math.round(window.innerHeight / 34);\r\nconst cols = Math.round(window.innerWidth / 27);\r\n\r\nlet hasStart = true;\r\nlet hasEnd = true;\r\nlet nodeStartRow = 2;\r\nlet nodeStartCol = 2;\r\nlet nodeEndRow = rows - 3;\r\nlet nodeEndCol = cols - 3;\r\nlet visualized = false;\r\nlet visualizing = false;\r\n\r\nconst Pathfind = () => {\r\n  const [Grid, setGrid] = useState([]);\r\n\r\n  useEffect(() => {\r\n    initializeGrid();\r\n  }, []);\r\n\r\n  const createSpot = (Grid) => {\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        Grid[i][j] = new Spot(i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  const initializeGrid = () => {\r\n    const Grid1 = new Array(rows);\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      Grid1[i] = new Array(cols);\r\n    }\r\n    createSpot(Grid1);\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  function Spot(i, j) {\r\n    this.x = i;\r\n    this.y = j;\r\n    this.f = 0;\r\n    this.h = 0;\r\n    this.g = 0;\r\n    this.mazeStatus = undefined;\r\n    this.wallNeighbors = [];\r\n    this.isWall = false;\r\n    this.connections = [];\r\n    this.addWallNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n\r\n      if (i > 1) {\r\n        this.wallNeighbors.push(grid[i - 2][j]);\r\n      }\r\n      if (i < rows - 2) {\r\n        this.wallNeighbors.push(grid[i + 2][j]);\r\n      }\r\n      if (j > 1) {\r\n        this.wallNeighbors.push(grid[i][j - 2]);\r\n      }\r\n      if (j < cols - 2) {\r\n        this.wallNeighbors.push(grid[i][j + 2]);\r\n      }\r\n    };\r\n\r\n    this.visited = false;\r\n    this.isStart = this.x === nodeStartRow && this.y === nodeStartCol;\r\n    this.isEnd = this.x === nodeEndRow && this.y === nodeEndCol;\r\n    this.neighbors = [];\r\n    this.previous = undefined;\r\n    this.addNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n      let rows = grid.length;\r\n      let cols = grid[1].length;\r\n\r\n      if (i > 0) {\r\n        this.neighbors.push(grid[i - 1][j]);\r\n      }\r\n      if (i < rows - 1) {\r\n        this.neighbors.push(grid[i + 1][j]);\r\n      }\r\n      if (j > 0) {\r\n        this.neighbors.push(grid[i][j - 1]);\r\n      }\r\n      if (j < cols - 1) {\r\n        this.neighbors.push(grid[i][j + 1]);\r\n      }\r\n\r\n      if (i > 0 && j > 0 && !(grid[i - 1][j].isWall && grid[i][j - 1].isWall)) {\r\n        this.neighbors.push(grid[i - 1][j - 1]);\r\n      }\r\n      if (\r\n        j < cols - 1 &&\r\n        i < rows - 1 &&\r\n        grid[i + 1][j].isWall == false &&\r\n        grid[i][j + 1].isWall == false\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j < cols - 1 &&\r\n        i > 0 &&\r\n        !(grid[i - 1][j].isWall && grid[i][j + 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i - 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j > 0 &&\r\n        i < rows - 1 &&\r\n        !(grid[i + 1][j].isWall && grid[i][j - 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j - 1]);\r\n      }\r\n    };\r\n  }\r\n\r\n  const addNeighbors = (grid) => {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        grid[i][j].addNeighbors(grid);\r\n      }\r\n    }\r\n  };\r\n\r\n  const [isDown, setDown] = useState(false);\r\n\r\n  const OnDown = (x, y) => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n    setDown(() => true);\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const OnUp = () => {\r\n    setDown(() => false);\r\n  };\r\n\r\n  const OnEnter = (x, y) => {\r\n    if (!isDown) {\r\n      return;\r\n    }\r\n\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const Reset = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        const node = Grid[i][j];\r\n        node.isWall = false;\r\n        node.neighbors = [];\r\n        node.class = node.isStart\r\n          ? \"node-start\"\r\n          : node.isEnd\r\n          ? \"node-end\"\r\n          : node.isWall\r\n          ? \"wall\"\r\n          : \"\";\r\n        document.getElementById(\r\n          `node-${node.x}-${node.y}`\r\n        ).className = `Node ${node.class}`;\r\n        node.f = 0;\r\n        node.h = 0;\r\n        node.g = 0;\r\n        node.visited = false;\r\n        node.neighbors = [];\r\n        node.previous = undefined;\r\n      }\r\n    }\r\n\r\n    visualized = false;\r\n    setGrid(() => Grid);\r\n  };\r\n  const wallUp = (x, y) => {\r\n    if (visualized) {\r\n      Reset();\r\n    }\r\n    let Grid1 = [...Grid];\r\n\r\n    if (!hasStart && !Grid1[x][y].isEnd) {\r\n      nodeStartRow = x;\r\n      nodeStartCol = y;\r\n      hasStart = true;\r\n      Grid1[x][y].isStart = true;\r\n    } else if (!hasEnd && !Grid1[x][y].isStart) {\r\n      nodeEndRow = x;\r\n      nodeEndCol = y;\r\n      hasEnd = true;\r\n      Grid1[x][y].isEnd = true;\r\n    } else if (Grid1[x][y].isEnd || Grid1[x][y].isStart || Grid1[x][y].isWall) {\r\n      if (Grid1[x][y].isEnd) {\r\n        nodeEndRow = null;\r\n        nodeEndCol = null;\r\n        hasEnd = false;\r\n        Grid1[x][y].isEnd = false;\r\n      }\r\n      if (Grid1[x][y].isStart) {\r\n        nodeStartRow = null;\r\n        nodeStartCol = null;\r\n        hasStart = false;\r\n        Grid1[x][y].isStart = false;\r\n      }\r\n      if (Grid1[x][y].isWall) {\r\n        Grid1[x][y].isWall = false;\r\n      }\r\n    } else {\r\n      Grid1[x][y].isWall = true;\r\n    }\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  const gridwithNode = (\r\n    <div>\r\n      {Grid.map((row, rowIndex) => {\r\n        return (\r\n          <div key={rowIndex} className=\"rowWrapper\">\r\n            {row.map((col, colIndex) => {\r\n              const { isStart, isEnd, isWall } = col;\r\n              return (\r\n                <Node\r\n                  key={colIndex}\r\n                  isStart={isStart}\r\n                  isEnd={isEnd}\r\n                  row={rowIndex}\r\n                  col={colIndex}\r\n                  OnEnter={OnEnter}\r\n                  OnDown={OnDown}\r\n                  isWall={isWall}\r\n                  OnUp={OnUp}\r\n                />\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  const shortestPath = (shortestPathNodes, startNode, endNode) => {\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPathNodes[i];\r\n        if (node !== startNode && node !== endNode) {\r\n          document.getElementById(`node-${node.x}-${node.y}`).className =\r\n            \"Node node-shortest\";\r\n        }\r\n      }, 5 * i);\r\n    }\r\n  };\r\n\r\n  function visualizePath() {\r\n    if (!hasStart || !hasEnd) {\r\n      return;\r\n    }\r\n    if (visualized) {\r\n      Reset();\r\n      return;\r\n    }\r\n    addNeighbors(Grid);\r\n    setGrid(() => Grid);\r\n\r\n    const startNode = Grid[nodeStartRow][nodeStartCol];\r\n    const endNode = Grid[nodeEndRow][nodeEndCol];\r\n\r\n    let path = dijkstra(startNode, endNode);\r\n\r\n    let Path = path.path;\r\n\r\n    let Visited = path.visitedNodes;\r\n\r\n    visualizing = true;\r\n\r\n    for (let i = 0; i <= Visited.length; i++) {\r\n      if (i === Visited.length) {\r\n        setTimeout(() => {\r\n          shortestPath(Path, startNode, endNode);\r\n          visualizing = false;\r\n        }, 16 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = Visited[i];\r\n          if (node !== startNode && node !== endNode) {\r\n            document.getElementById(`node-${node.x}-${node.y}`).className =\r\n              \"Node node-visited\";\r\n          }\r\n        }, 15 * i);\r\n      }\r\n    }\r\n    visualized = true;\r\n  }\r\n\r\n  const randomWalls = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    Reset();\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        if (Grid[i][j].isEnd || Grid[i][j].isStart) {\r\n        } else if (Math.random(1) < 0.2) {\r\n          Grid[i][j].isWall = true;\r\n          document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\r\n        } else {\r\n          Grid[i][j].isWall = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    setGrid(() => Grid);\r\n  };\r\n\r\n  function generateMaze() {\r\n    if (!hasStart || !hasEnd || visualizing) {\r\n      return;\r\n    }\r\n\r\n    setGrid(() => Rmaze(Grid));\r\n    visualizing = true;\r\n    // for (let i = 0; i < Grid.length; i++) {\r\n    //   setTimeout(() => {\r\n    //     for (let j = 0; j < Grid[i].length; j++) {\r\n    //       setTimeout(() => {\r\n    //         const node = Grid[i][j];\r\n    //         if (!node.isStart && !node.IsEnd && node.isWall) {\r\n    //           document.getElementById(`node-${node.x}-${node.y}`).className =\r\n    //             \"Node wall\";\r\n    //         } else if (!node.isStart && !node.isEnd && !node.isWall) {\r\n    //           document.getElementById(`node-${node.x}-${node.y}`).className =\r\n    //             \"Node\";\r\n    //         }\r\n    //         if (j == Grid[i].length - 1 && i == Grid.length - 1) {\r\n    //           visualizing = false;\r\n    //         }\r\n    //       }, 0 * j);\r\n    //     }\r\n    //   }, 0 * i);\r\n    // }\r\n    visualized = false;\r\n  }\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"header\">\r\n        <h1 className=\"title\">Pathfinding Visualizer</h1>\r\n      </div>\r\n      <div className=\"header\">\r\n        <p>\r\n          click and drag to create walls - replace start and end nodes with\r\n          click\r\n        </p>\r\n      </div>\r\n      <div className=\"row\">\r\n        <div className=\"col-sm\">\r\n          <button onClick={visualizePath}>Vizualize Path (A*)</button>\r\n        </div>\r\n\r\n        <div className=\"col-sm\">\r\n          <button onClick={randomWalls}>Random Walls</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={Reset}>Reset</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={generateMaze}>\r\n            Generate Maze (Prim's Algorithm)\r\n          </button>\r\n        </div>\r\n      </div>\r\n      {gridwithNode}\r\n    </div>\r\n  );\r\n};\r\nexport default Pathfind;\r\n","import React from \"react\";\r\nimport Pathfind from \"./Components/pathfind.js\";\r\n\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <Pathfind />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <App />,\r\n\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}