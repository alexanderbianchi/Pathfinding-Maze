{"version":3,"sources":["Components/Node.js","Algorithms/dijkstras.js","Algorithms/Prims Algorithm.js","Components/pathfind.js","App.js","index.js"],"names":["Node","props","classes","isStart","isEnd","isWall","className","id","row","col","onMouseOver","x","y","OnEnter","onMouseDown","OnDown","onMouseUp","OnUp","heuristic","a","b","Math","abs","dijkstra","startNode","endNode","openSet","closedSet","path","visitedNodes","push","leastIndex","i","length","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","error","shuffleArray","array","j","floor","random","getRandomItem","set","items","Array","from","Rmaze","grid","frontier","Set","visited","start","uniqueSet","addWallNeighbors","wallNeighbors","add","mazeStatus","WallSetup","Recurse","delete","curN","size","adj","rand","rows","round","window","innerHeight","cols","innerWidth","hasStart","hasEnd","nodeStartRow","nodeStartCol","nodeEndRow","nodeEndCol","visualized","visualizing","Pathfind","useState","Grid","setGrid","useEffect","initializeGrid","Grid1","Spot","createSpot","this","undefined","connections","addNeighbors","isDown","setDown","wallUp","Reset","node","class","document","getElementById","gridwithNode","map","rowIndex","colIndex","onClick","Path","Visited","setTimeout","shortestPathNodes","shortestPath","IsEnd","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.cae42dbe.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  //console.log(props.isStart);\r\n  const classes = props.isStart\r\n    ? \"node-start\"\r\n    : props.isEnd\r\n    ? \"node-end\"\r\n    : props.isWall\r\n    ? \"wall\"\r\n    : \"\";\r\n  return (\r\n    <button\r\n      className={`Node ${classes}`}\r\n      id={`node-${props.row}-${props.col}`}\r\n      onMouseOver={(x, y) => props.OnEnter(props.row, props.col)}\r\n      onMouseDown={(x, y) => props.OnDown(props.row, props.col)}\r\n      onMouseUp={() => props.OnUp()}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","function dijkstra(startNode, endNode) {\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n    visitedNodes.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"no path\" };\r\n}\r\n\r\nfunction heuristic(a, b) {\r\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n  //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\r\n  return d;\r\n}\r\n\r\nexport default dijkstra;\r\n","function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    grid[(rand.x + 1 + current.x + 1) / 2 - 1][\r\n      (rand.y + 1 + current.y + 1) / 2 - 1\r\n    ].isWall = false;\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Node from \"./Node.js\";\r\nimport \"./Pathfind.css\";\r\nimport dijkstra from \"../Algorithms/dijkstras.js\";\r\nimport Rmaze from \"../Algorithms/Prims Algorithm.js\";\r\n\r\nconst rows = Math.round(window.innerHeight / 34);\r\nconst cols = Math.round(window.innerWidth / 27);\r\n\r\nlet hasStart = true;\r\nlet hasEnd = true;\r\nlet nodeStartRow = 2;\r\nlet nodeStartCol = 2;\r\nlet nodeEndRow = rows - 3;\r\nlet nodeEndCol = cols - 3;\r\nlet visualized = false;\r\nlet visualizing = false;\r\n\r\nconst Pathfind = () => {\r\n  const [Grid, setGrid] = useState([]);\r\n\r\n  useEffect(() => {\r\n    initializeGrid();\r\n  }, []);\r\n\r\n  const createSpot = (Grid) => {\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        Grid[i][j] = new Spot(i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  const initializeGrid = () => {\r\n    const Grid1 = new Array(rows);\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      Grid1[i] = new Array(cols);\r\n    }\r\n    createSpot(Grid1);\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  function Spot(i, j) {\r\n    this.x = i;\r\n    this.y = j;\r\n    this.f = 0;\r\n    this.h = 0;\r\n    this.g = 0;\r\n    this.mazeStatus = undefined;\r\n    this.wallNeighbors = [];\r\n    this.isWall = false;\r\n    this.connections = [];\r\n    this.addWallNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n\r\n      if (i > 1) {\r\n        this.wallNeighbors.push(grid[i - 2][j]);\r\n      }\r\n      if (i < rows - 2) {\r\n        this.wallNeighbors.push(grid[i + 2][j]);\r\n      }\r\n      if (j > 1) {\r\n        this.wallNeighbors.push(grid[i][j - 2]);\r\n      }\r\n      if (j < cols - 2) {\r\n        this.wallNeighbors.push(grid[i][j + 2]);\r\n      }\r\n    };\r\n\r\n    this.visited = false;\r\n    this.isStart = this.x === nodeStartRow && this.y === nodeStartCol;\r\n    this.isEnd = this.x === nodeEndRow && this.y === nodeEndCol;\r\n    this.neighbors = [];\r\n    this.previous = undefined;\r\n    this.addNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n      let rows = grid.length;\r\n      let cols = grid[1].length;\r\n\r\n      if (i > 0) {\r\n        this.neighbors.push(grid[i - 1][j]);\r\n      }\r\n      if (i < rows - 1) {\r\n        this.neighbors.push(grid[i + 1][j]);\r\n      }\r\n      if (j > 0) {\r\n        this.neighbors.push(grid[i][j - 1]);\r\n      }\r\n      if (j < cols - 1) {\r\n        this.neighbors.push(grid[i][j + 1]);\r\n      }\r\n\r\n      if (i > 0 && j > 0 && !(grid[i - 1][j].isWall && grid[i][j - 1].isWall)) {\r\n        this.neighbors.push(grid[i - 1][j - 1]);\r\n      }\r\n      if (\r\n        j < cols - 1 &&\r\n        i < rows - 1 &&\r\n        grid[i + 1][j].isWall == false &&\r\n        grid[i][j + 1].isWall == false\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j < cols - 1 &&\r\n        i > 0 &&\r\n        !(grid[i - 1][j].isWall && grid[i][j + 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i - 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j > 0 &&\r\n        i < rows - 1 &&\r\n        !(grid[i + 1][j].isWall && grid[i][j - 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j - 1]);\r\n      }\r\n    };\r\n  }\r\n\r\n  const addNeighbors = (grid) => {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        grid[i][j].addNeighbors(grid);\r\n      }\r\n    }\r\n  };\r\n\r\n  const [isDown, setDown] = useState(false);\r\n\r\n  const OnDown = (x, y) => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n    setDown(() => true);\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const OnUp = () => {\r\n    setDown(() => false);\r\n  };\r\n\r\n  const OnEnter = (x, y) => {\r\n    if (!isDown) {\r\n      return;\r\n    }\r\n\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const Reset = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        const node = Grid[i][j];\r\n        node.isWall = false;\r\n        node.neighbors = [];\r\n        node.class = node.isStart\r\n          ? \"node-start\"\r\n          : node.isEnd\r\n          ? \"node-end\"\r\n          : node.isWall\r\n          ? \"wall\"\r\n          : \"\";\r\n        document.getElementById(\r\n          `node-${node.x}-${node.y}`\r\n        ).className = `Node ${node.class}`;\r\n        node.f = 0;\r\n        node.h = 0;\r\n        node.g = 0;\r\n        node.visited = false;\r\n        node.neighbors = [];\r\n        node.previous = undefined;\r\n      }\r\n    }\r\n\r\n    visualized = false;\r\n    setGrid(() => Grid);\r\n  };\r\n  const wallUp = (x, y) => {\r\n    if (visualized) {\r\n      Reset();\r\n    }\r\n    let Grid1 = [...Grid];\r\n\r\n    if (!hasStart && !Grid1[x][y].isEnd) {\r\n      nodeStartRow = x;\r\n      nodeStartCol = y;\r\n      hasStart = true;\r\n      Grid1[x][y].isStart = true;\r\n    } else if (!hasEnd && !Grid1[x][y].isStart) {\r\n      nodeEndRow = x;\r\n      nodeEndCol = y;\r\n      hasEnd = true;\r\n      Grid1[x][y].isEnd = true;\r\n    } else if (Grid1[x][y].isEnd || Grid1[x][y].isStart || Grid1[x][y].isWall) {\r\n      if (Grid1[x][y].isEnd) {\r\n        nodeEndRow = null;\r\n        nodeEndCol = null;\r\n        hasEnd = false;\r\n        Grid1[x][y].isEnd = false;\r\n      }\r\n      if (Grid1[x][y].isStart) {\r\n        nodeStartRow = null;\r\n        nodeStartCol = null;\r\n        hasStart = false;\r\n        Grid1[x][y].isStart = false;\r\n      }\r\n      if (Grid1[x][y].isWall) {\r\n        Grid1[x][y].isWall = false;\r\n      }\r\n    } else {\r\n      Grid1[x][y].isWall = true;\r\n    }\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  const gridwithNode = (\r\n    <div>\r\n      {Grid.map((row, rowIndex) => {\r\n        return (\r\n          <div key={rowIndex} className=\"rowWrapper\">\r\n            {row.map((col, colIndex) => {\r\n              const { isStart, isEnd, isWall } = col;\r\n              return (\r\n                <Node\r\n                  key={colIndex}\r\n                  isStart={isStart}\r\n                  isEnd={isEnd}\r\n                  row={rowIndex}\r\n                  col={colIndex}\r\n                  OnEnter={OnEnter}\r\n                  OnDown={OnDown}\r\n                  isWall={isWall}\r\n                  OnUp={OnUp}\r\n                />\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  const shortestPath = (shortestPathNodes, startNode, endNode) => {\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPathNodes[i];\r\n        if (node !== startNode && node !== endNode) {\r\n          document.getElementById(`node-${node.x}-${node.y}`).className =\r\n            \"Node node-shortest\";\r\n        }\r\n      }, 5 * i);\r\n    }\r\n  };\r\n\r\n  function visualizePath() {\r\n    if (!hasStart || !hasEnd) {\r\n      return;\r\n    }\r\n    if (visualized) {\r\n      Reset();\r\n      return;\r\n    }\r\n    addNeighbors(Grid);\r\n    setGrid(() => Grid);\r\n\r\n    const startNode = Grid[nodeStartRow][nodeStartCol];\r\n    const endNode = Grid[nodeEndRow][nodeEndCol];\r\n\r\n    let path = dijkstra(startNode, endNode);\r\n\r\n    let Path = path.path;\r\n\r\n    let Visited = path.visitedNodes;\r\n\r\n    visualizing = true;\r\n\r\n    for (let i = 0; i <= Visited.length; i++) {\r\n      if (i === Visited.length) {\r\n        setTimeout(() => {\r\n          shortestPath(Path, startNode, endNode);\r\n          visualizing = false;\r\n        }, 16 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = Visited[i];\r\n          if (node !== startNode && node !== endNode) {\r\n            document.getElementById(`node-${node.x}-${node.y}`).className =\r\n              \"Node node-visited\";\r\n          }\r\n        }, 15 * i);\r\n      }\r\n    }\r\n    visualized = true;\r\n  }\r\n\r\n  const randomWalls = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    Reset();\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        if (Grid[i][j].isEnd || Grid[i][j].isStart) {\r\n        } else if (Math.random(1) < 0.2) {\r\n          Grid[i][j].isWall = true;\r\n          document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\r\n        } else {\r\n          Grid[i][j].isWall = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    setGrid(() => Grid);\r\n  };\r\n\r\n  function generateMaze() {\r\n    if (!hasStart || !hasEnd || visualizing) {\r\n      return;\r\n    }\r\n\r\n    setGrid(() => Rmaze(Grid));\r\n    visualizing = true;\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      setTimeout(() => {\r\n        for (let j = 0; j < Grid[i].length; j++) {\r\n          setTimeout(() => {\r\n            const node = Grid[i][j];\r\n            if (!node.isStart && !node.IsEnd && node.isWall) {\r\n              document.getElementById(`node-${node.x}-${node.y}`).className =\r\n                \"Node wall\";\r\n            } else if (!node.isStart && !node.isEnd && !node.isWall) {\r\n              document.getElementById(`node-${node.x}-${node.y}`).className =\r\n                \"Node\";\r\n            }\r\n            if (j == Grid[i].length - 1 && i == Grid.length - 1) {\r\n              visualizing = false;\r\n            }\r\n          }, 0 * j);\r\n        }\r\n      }, 0 * i);\r\n    }\r\n    visualized = false;\r\n  }\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"header\">\r\n        <h1 className=\"title\">Pathfinding Visualizer</h1>\r\n      </div>\r\n      <div className=\"header\">\r\n        <p>\r\n          click and drag to create walls - replace start and end nodes with\r\n          click\r\n        </p>\r\n      </div>\r\n      <div className=\"row\">\r\n        <div className=\"col-sm\">\r\n          <button onClick={visualizePath}>Vizualize Path (A*)</button>\r\n        </div>\r\n\r\n        <div className=\"col-sm\">\r\n          <button onClick={randomWalls}>Random Walls</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={Reset}>Reset</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={generateMaze}>\r\n            Generate Maze (Prim's Algorithm)\r\n          </button>\r\n        </div>\r\n      </div>\r\n      {gridwithNode}\r\n    </div>\r\n  );\r\n};\r\nexport default Pathfind;\r\n","import React from \"react\";\r\nimport Pathfind from \"./Components/pathfind.js\";\r\n\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <Pathfind />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <App />,\r\n\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}