{"version":3,"sources":["Components/Node.js","Algorithms/dijkstras.js","Algorithms/Prims Algorithm.js","Components/pathfind.js","App.js","index.js"],"names":["Node","props","classes","isStart","isEnd","isWall","className","id","row","col","onMouseOver","x","y","OnEnter","onMouseDown","OnDown","heuristic","a","b","Math","abs","dijkstra","startNode","endNode","openSet","closedSet","path","visitedNodes","push","leastIndex","i","length","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","error","shuffleArray","array","j","floor","random","getRandomItem","set","items","Array","from","toV","Rmaze","grid","frontier","Set","visited","start","uniqueSet","addWallNeighbors","wallNeighbors","document","getElementById","add","IsEnd","mazeStatus","WallSetup","Recurse","delete","curN","size","adj","rand","xFall","yFall","setTimeout","rows","round","window","innerHeight","cols","innerWidth","hasStart","hasEnd","nodeStartRow","nodeStartCol","nodeEndRow","nodeEndCol","visualized","visualizing","Pathfind","useState","Grid","setGrid","useEffect","initializeGrid","Grid1","Spot","createSpot","this","undefined","connections","inTransition","addNeighbors","isDown","setDown","wallUp","OnUp","Reset","node","class","gridwithNode","onMouseUp","map","rowIndex","colIndex","onClick","Path","Visited","shortestPathNodes","shortestPath","App","ReactDOM","render"],"mappings":"kNAsBeA,EAnBF,SAACC,GAEZ,IAAMC,EAAUD,EAAME,QAClB,aACAF,EAAMG,MACN,WACAH,EAAMI,OACN,OACA,GACJ,OACE,wBACEC,UAAS,eAAUJ,GACnBK,GAAE,eAAUN,EAAMO,IAAhB,YAAuBP,EAAMQ,KAC/BC,YAAa,SAACC,EAAGC,GAAJ,OAAUX,EAAMY,QAAQZ,EAAMO,IAAKP,EAAMQ,MACtDK,YAAa,SAACH,EAAGC,GAAJ,OAAUX,EAAMc,OAAOd,EAAMO,IAAKP,EAAMQ,S,MC6C3D,SAASO,EAAUC,EAAGC,GAGpB,OAFQC,KAAKC,IAAIH,EAAEN,EAAIO,EAAEP,GAAKQ,KAAKC,IAAIH,EAAEL,EAAIM,EAAEN,GAKlCS,MApEf,SAAkBC,EAAWC,GAC3B,IAAIC,EAAU,GACVC,EAAY,GACZC,EAAO,GACPC,EAAe,GAEnBH,EAAQI,KAAKN,GACb,IAPoC,iBASlC,IADA,IAAIO,EAAa,EACRC,EAAI,EAAGA,EAAIN,EAAQO,OAAQD,IAC9BN,EAAQM,GAAGE,EAAIR,EAAQK,GAAYG,IACrCH,EAAaC,GAIjB,IAAIG,EAAUT,EAAQK,GAGtB,GAFAF,EAAaC,KAAKK,GAEdA,IAAYV,EAAS,CACvB,IAAIW,EAAOD,EAEX,IADAP,EAAKE,KAAKM,GACHA,EAAKC,UACVT,EAAKE,KAAKM,EAAKC,UACfD,EAAOA,EAAKC,SAGd,MAAM,CAAN,EAAO,CAAET,OAAMC,iBAGjBH,EAAUA,EAAQY,QAAO,SAACC,GAAD,OAASA,IAAQJ,KAC1CR,EAAUG,KAAKK,GAIf,IAFA,IAAIK,EAAYL,EAAQK,UAEfR,EAAI,EAAGA,EAAIQ,EAAUP,OAAQD,IAAK,CACzC,IAAIS,EAAWD,EAAUR,GACzB,IAAKL,EAAUe,SAASD,KAAcA,EAASlC,OAAQ,CACrD,IAAIoC,EAAQR,EAAQS,EAAI,EACpBC,GAAU,EACVnB,EAAQgB,SAASD,GACfE,EAAQF,EAASG,IACnBH,EAASG,EAAID,EACbE,GAAU,IAGZJ,EAASG,EAAID,EACbE,GAAU,EACVnB,EAAQI,KAAKW,IAGXI,IACFJ,EAASK,EAAI5B,EAAUuB,EAAUhB,GACjCgB,EAASP,EAAIO,EAASK,EAAIL,EAASG,EACnCH,EAASJ,SAAWF,MA9CrBT,EAAQO,OAAS,GAAG,CAAC,IAAD,wCAoD3B,MAAO,CAAEL,OAAMC,eAAckB,MAAO,YC3DtC,SAASC,EAAaC,GACpB,GAAoB,GAAhBA,EAAMhB,OAAV,CAGA,IAAK,IAAID,EAAIiB,EAAMhB,OAAS,EAAGD,EAAI,EAAGA,IAAK,CACzC,IAAIkB,EAAI7B,KAAK8B,MAAM9B,KAAK+B,UAAYpB,EAAI,IACpCI,EAAOa,EAAMjB,GACjBiB,EAAMjB,GAAKiB,EAAMC,GACjBD,EAAMC,GAAKd,EAGb,OAAOa,EAAM,IAEf,SAASI,EAAcC,GACrB,IAAIC,EAAQC,MAAMC,KAAKH,GACvB,OAAOC,EAAMlC,KAAK8B,MAAM9B,KAAK+B,SAAWG,EAAMtB,SAGhD,IAAIyB,EAAM,GA2FKC,MA1Ff,SAAeC,GACb,IA2BIC,EAAW,IAAIC,IACfC,EAAU,IAAID,IAEdE,EAAQX,EA9BM,SAACO,GAEjB,IADA,IAAIK,EAAY,IAAIH,IACX9B,EAAI,EAAGA,EAAI4B,EAAK3B,OAAQD,IAC/B,IAAK,IAAIkB,EAAI,EAAGA,EAAIU,EAAK5B,GAAGC,OAAQiB,IAC9BlB,EAAI,GAAK,GAAKkB,EAAI,GAAK,GACzBU,EAAK5B,GAAGkB,GAAGgB,iBAAiBN,GAE5BZ,EAAaY,EAAK5B,GAAGkB,GAAGiB,eAExBP,EAAK5B,GAAGkB,GAAG3C,QAAS,EACfqD,EAAK5B,GAAGkB,GAAG7C,SAAYuD,EAAK5B,GAAGkB,GAAG5C,OAAUsD,EAAK5B,GAAGkB,GAAG3C,SAC1D6D,SAASC,eAAT,eAAgCrC,EAAhC,YAAqCkB,IAAK1C,UAAY,QAExDyD,EAAUK,IAAIV,EAAK5B,GAAGkB,KAEjBU,EAAK5B,GAAGkB,GAAG7C,SAAYuD,EAAK5B,GAAGkB,GAAG5C,QACrCsD,EAAK5B,GAAGkB,GAAG3C,QAAS,EACfqD,EAAK5B,GAAGkB,GAAG7C,SAAYuD,EAAK5B,GAAGkB,GAAGqB,QAASX,EAAK5B,GAAGkB,GAAG3C,SACzD6D,SAASC,eAAT,eAAgCrC,EAAhC,YAAqCkB,IAAK1C,UAAY,cAI5DoD,EAAK5B,GAAGkB,GAAGsB,WAAa,YAG5B,OAAOP,EAKiBQ,CAAUb,IACpCC,EAASS,IAAIN,GACbD,EAAQO,IAAIN,GACZ,IAAI7B,EAAU6B,EACd7B,EAAQqC,WAAa,UAErB,SAASE,EAAQd,GACfC,EAASc,OAAOxC,GAIhB,IAFA,IAAIyC,EAAOzC,EAAQgC,cAEVnC,EAAI,EAAGA,EAAI4C,EAAK3C,OAAQD,IACL,aAAtB4C,EAAK5C,GAAGwC,WACVX,EAASS,IAAIM,EAAK5C,IAET4C,EAAK5C,GAAGwC,WAKrB,GAAqB,GAAjBX,EAASgB,KAAb,CAGA1C,EAAUkB,EAAcQ,GACxBE,EAAQO,IAAInC,GACZA,EAAQqC,WAAa,UAGrB,IADA,IAAIM,EAAM,GACD9C,EAAI,EAAGA,EAAIG,EAAQgC,cAAclC,OAAQD,IACL,WAAvCG,EAAQgC,cAAcnC,GAAGwC,YAC3BM,EAAIhD,KAAKK,EAAQgC,cAAcnC,IAGnC,IAAI+C,EAAO/B,EAAa8B,GAEpBE,GAASD,EAAKlE,EAAI,EAAIsB,EAAQtB,EAAI,GAAK,EAAI,EAC3CoE,GAASF,EAAKjE,EAAI,EAAIqB,EAAQrB,EAAI,GAAK,EAAI,EAC/C8C,EAAKoB,GAAOC,GAAO1E,QAAS,EAE5BmD,EAAI5B,KAAK,CAACkD,EAAOC,IAEbpB,EAASgB,KAAO,GAClBH,EAAQd,IAGZc,CAAQd,GAER,IA9EmB,eA8EV5B,GACP,IAAInB,EAAI6C,EAAI1B,GAAG,GACXlB,EAAI4C,EAAI1B,GAAG,GACV4B,EAAK/C,GAAGC,GAAGT,SAAYuD,EAAK/C,GAAGC,GAAGR,OAAUsD,EAAK/C,GAAGC,GAAGP,QAC1D2E,YAAW,WACTd,SAASC,eAAT,eAAgCxD,EAAhC,YAAqCC,IAAKN,UAAY,SACjD,GAAJwB,IANEA,EAAI,EAAGA,EAAI0B,EAAIzB,OAAQD,IAAM,EAA7BA,GAUT,OAAO4B,GCrGHuB,EAAO9D,KAAK+D,MAAMC,OAAOC,YAAc,IACvCC,EAAOlE,KAAK+D,MAAMC,OAAOG,WAAa,IAExCC,GAAW,EACXC,GAAS,EACTC,EAAe,EACfC,EAAe,EACfC,EAAaV,EAAO,EACpBW,EAAaP,EAAO,EACpBQ,GAAa,EACbC,GAAc,EA2XHC,EAzXE,WAAO,IAAD,EACGC,mBAAS,IADZ,mBACdC,EADc,KACRC,EADQ,KAGrBC,qBAAU,WACRC,MACC,IAEH,IAQMA,EAAiB,WAGrB,IAFA,IAAMC,EAAQ,IAAI/C,MAAM2B,GAEfnD,EAAI,EAAGA,EAAImD,EAAMnD,IACxBuE,EAAMvE,GAAK,IAAIwB,MAAM+B,IAZN,SAACY,GAClB,IAAK,IAAInE,EAAI,EAAGA,EAAImD,EAAMnD,IACxB,IAAK,IAAIkB,EAAI,EAAGA,EAAIqC,EAAMrC,IACxBiD,EAAKnE,GAAGkB,GAAK,IAAIsD,EAAKxE,EAAGkB,GAW7BuD,CAAWF,GAEXH,GAAQ,kBAAMG,MAGhB,SAASC,EAAKxE,EAAGkB,GACfwD,KAAK7F,EAAImB,EACT0E,KAAK5F,EAAIoC,EACTwD,KAAKxE,EAAI,EACTwE,KAAK5D,EAAI,EACT4D,KAAK9D,EAAI,EACT8D,KAAKlC,gBAAamC,EAClBD,KAAKvC,cAAgB,GACrBuC,KAAKnG,QAAS,EACdmG,KAAKE,YAAc,GACnBF,KAAKxC,iBAAmB,SAAUN,GAChC,IAAI5B,EAAI0E,KAAK7F,EACTqC,EAAIwD,KAAK5F,EAETkB,EAAI,GACN0E,KAAKvC,cAAcrC,KAAK8B,EAAK5B,EAAI,GAAGkB,IAElClB,EAAImD,EAAO,GACbuB,KAAKvC,cAAcrC,KAAK8B,EAAK5B,EAAI,GAAGkB,IAElCA,EAAI,GACNwD,KAAKvC,cAAcrC,KAAK8B,EAAK5B,GAAGkB,EAAI,IAElCA,EAAIqC,EAAO,GACbmB,KAAKvC,cAAcrC,KAAK8B,EAAK5B,GAAGkB,EAAI,KAGxCwD,KAAKG,cAAe,EACpBH,KAAK3C,SAAU,EACf2C,KAAKrG,QAAUqG,KAAK7F,IAAM8E,GAAgBe,KAAK5F,IAAM8E,EACrDc,KAAKpG,MAAQoG,KAAK7F,IAAMgF,GAAca,KAAK5F,IAAMgF,EACjDY,KAAKlE,UAAY,GACjBkE,KAAKrE,cAAWsE,EAChBD,KAAKI,aAAe,SAAUlD,GAC5B,IAAI5B,EAAI0E,KAAK7F,EACTqC,EAAIwD,KAAK5F,EACTqE,EAAOvB,EAAK3B,OACZsD,EAAO3B,EAAK,GAAG3B,OAEfD,EAAI,GACN0E,KAAKlE,UAAUV,KAAK8B,EAAK5B,EAAI,GAAGkB,IAE9BlB,EAAImD,EAAO,GACbuB,KAAKlE,UAAUV,KAAK8B,EAAK5B,EAAI,GAAGkB,IAE9BA,EAAI,GACNwD,KAAKlE,UAAUV,KAAK8B,EAAK5B,GAAGkB,EAAI,IAE9BA,EAAIqC,EAAO,GACbmB,KAAKlE,UAAUV,KAAK8B,EAAK5B,GAAGkB,EAAI,MAG9BlB,EAAI,GAAKkB,EAAI,IAAOU,EAAK5B,EAAI,GAAGkB,GAAG3C,QAAUqD,EAAK5B,GAAGkB,EAAI,GAAG3C,QAC9DmG,KAAKlE,UAAUV,KAAK8B,EAAK5B,EAAI,GAAGkB,EAAI,IAGpCA,EAAIqC,EAAO,GACXvD,EAAImD,EAAO,GACc,GAAzBvB,EAAK5B,EAAI,GAAGkB,GAAG3C,QACU,GAAzBqD,EAAK5B,GAAGkB,EAAI,GAAG3C,QAEfmG,KAAKlE,UAAUV,KAAK8B,EAAK5B,EAAI,GAAGkB,EAAI,MAIpCA,EAAIqC,EAAO,GACXvD,EAAI,IACF4B,EAAK5B,EAAI,GAAGkB,GAAG3C,QAAUqD,EAAK5B,GAAGkB,EAAI,GAAG3C,QAE1CmG,KAAKlE,UAAUV,KAAK8B,EAAK5B,EAAI,GAAGkB,EAAI,MAIpCA,EAAI,GACJlB,EAAImD,EAAO,IACTvB,EAAK5B,EAAI,GAAGkB,GAAG3C,QAAUqD,EAAK5B,GAAGkB,EAAI,GAAG3C,QAE1CmG,KAAKlE,UAAUV,KAAK8B,EAAK5B,EAAI,GAAGkB,EAAI,KAK1C,IA5GqB,EAoHKgD,oBAAS,GApHd,mBAoHda,EApHc,KAoHNC,EApHM,KAsHf/F,EAAS,SAACJ,EAAGC,GACbkF,IAGJgB,GAAQ,kBAAM,KACdC,EAAOpG,EAAGC,KAGNoG,EAAO,WACXF,GAAQ,kBAAM,MAGVjG,EAAU,SAACF,EAAGC,GACbiG,GAAqC,GAA3BZ,EAAKtF,GAAGC,GAAG+F,cAI1BI,EAAOpG,EAAGC,IAGNqG,EAAQ,WACZ,IAAInB,EAAJ,CAIA,IAAK,IAAIhE,EAAI,EAAGA,EAAImE,EAAKlE,OAAQD,IAC/B,IAAK,IAAIkB,EAAI,EAAGA,EAAIiD,EAAKnE,GAAGC,OAAQiB,IAAK,CACvC,IAAMkE,EAAOjB,EAAKnE,GAAGkB,GACrBkE,EAAK7G,QAAS,EACd6G,EAAK5E,UAAY,GACjB4E,EAAKC,MAAQD,EAAK/G,QACd,aACA+G,EAAK9G,MACL,WACA8G,EAAK7G,OACL,OACA,GACJ6D,SAASC,eAAT,eACU+C,EAAKvG,EADf,YACoBuG,EAAKtG,IACvBN,UAFF,eAEsB4G,EAAKC,OAC3BD,EAAKlF,EAAI,EACTkF,EAAKtE,EAAI,EACTsE,EAAKxE,EAAI,EACTwE,EAAKrD,SAAU,EACfqD,EAAK5E,UAAY,GACjB4E,EAAK/E,cAAWsE,EAIpBZ,GAAa,EACbK,GAAQ,kBAAMD,OAEVc,EAAS,SAACpG,EAAGC,GACbiF,GACFoB,IAEFhB,EAAKtF,GAAGC,GAAG+F,cAAe,EAC1B3B,YAAW,WACTiB,EAAKtF,GAAGC,GAAG+F,cAAe,IACzB,KACH,IAAIN,EAAK,YAAOJ,GAEXV,GAAac,EAAM1F,GAAGC,GAAGR,MAKlBoF,GAAWa,EAAM1F,GAAGC,GAAGT,QAKxBkG,EAAM1F,GAAGC,GAAGR,OAASiG,EAAM1F,GAAGC,GAAGT,SAAWkG,EAAM1F,GAAGC,GAAGP,QAC7DgG,EAAM1F,GAAGC,GAAGR,QACduF,EAAa,KACbC,EAAa,KACbJ,GAAS,EACTa,EAAM1F,GAAGC,GAAGR,OAAQ,GAElBiG,EAAM1F,GAAGC,GAAGT,UACdsF,EAAe,KACfC,EAAe,KACfH,GAAW,EACXc,EAAM1F,GAAGC,GAAGT,SAAU,GAEpBkG,EAAM1F,GAAGC,GAAGP,SACdgG,EAAM1F,GAAGC,GAAGP,QAAS,IAGvBgG,EAAM1F,GAAGC,GAAGP,QAAS,GArBrBsF,EAAahF,EACbiF,EAAahF,EACb4E,GAAS,EACTa,EAAM1F,GAAGC,GAAGR,OAAQ,IARpBqF,EAAe9E,EACf+E,EAAe9E,EACf2E,GAAW,EACXc,EAAM1F,GAAGC,GAAGT,SAAU,GA0BxB+F,GAAQ,kBAAMG,MAGVe,EACJ,qBAAKC,UAAW,kBAAML,KAAtB,SACGf,EAAKqB,KAAI,SAAC9G,EAAK+G,GACd,OACE,qBAAoBjH,UAAU,aAA9B,SACGE,EAAI8G,KAAI,SAAC7G,EAAK+G,GAAc,IACnBrH,EAA2BM,EAA3BN,QAASC,EAAkBK,EAAlBL,MAAOC,EAAWI,EAAXJ,OACxB,OACE,cAAC,EAAD,CAEEF,QAASA,EACTC,MAAOA,EACPI,IAAK+G,EACL9G,IAAK+G,EACL3G,QAASA,EACTE,OAAQA,EACRV,OAAQA,EACR2G,KAAMA,GARDQ,OALHD,QAgIlB,OACE,sBAAKjH,UAAU,YAAf,UACE,qBAAKA,UAAU,SAAf,SACE,oBAAIA,UAAU,QAAd,sCAEF,qBAAKA,UAAU,SAAf,SACE,0GAKF,sBAAKA,UAAU,MAAf,UACE,qBAAKA,UAAU,SAAf,SACE,wBAAQmH,QA1GhB,WACE,GAAKlC,GAAaC,IAAUM,EAG5B,GAAID,EACFoB,QADF,EApJmB,SAACvD,GACpB,IAAK,IAAI5B,EAAI,EAAGA,EAAI4B,EAAK3B,OAAQD,IAC/B,IAAK,IAAIkB,EAAI,EAAGA,EAAIU,EAAK5B,GAAGC,OAAQiB,IAClCU,EAAK5B,GAAGkB,GAAG4D,aAAalD,GAqJ5BkD,CAAaX,GACbC,GAAQ,kBAAMD,KAEd,IAAM3E,EAAY2E,EAAKR,GAAcC,GAC/BnE,EAAU0E,EAAKN,GAAYC,GAE7BlE,EAAOL,EAASC,EAAWC,GAE3BmG,EAAOhG,EAAKA,KAEZiG,EAAUjG,EAAKC,aAEnBmE,GAAc,EAEd,IAtBuB,eAsBdhE,GACHA,IAAM6F,EAAQ5F,OAChBiD,YAAW,YApCI,SAAC4C,EAAmBtG,EAAWC,GAClD,IAD+D,IAAD,WACrDO,GACPkD,YAAW,WACT,IAAMkC,EAAOU,EAAkB9F,GAC3BoF,IAAS5F,GAAa4F,IAAS3F,IACjC2C,SAASC,eAAT,eAAgC+C,EAAKvG,EAArC,YAA0CuG,EAAKtG,IAAKN,UAClD,wBAEH,EAAIwB,IAPAA,EAAI,EAAGA,EAAI8F,EAAkB7F,OAAQD,IAAM,EAA3CA,GAoCH+F,CAAaH,EAAMpG,EAAWC,GAC9BuE,GAAc,IACb,GAAKhE,GAERkD,YAAW,WACT,IAAMkC,EAAOS,EAAQ7F,GACjBoF,IAAS5F,GAAa4F,IAAS3F,IACjC2C,SAASC,eAAT,eAAgC+C,EAAKvG,EAArC,YAA0CuG,EAAKtG,IAAKN,UAClD,uBAEH,GAAKwB,IAbHA,EAAI,EAAGA,GAAK6F,EAAQ5F,OAAQD,IAAM,EAAlCA,GAgBT+D,GAAa,IAoEP,mCAGF,qBAAKvF,UAAU,SAAf,SACE,wBAAQmH,QArEI,WAClB,IAAI3B,EAAJ,CAIAmB,IAEA,IAAK,IAAInF,EAAI,EAAGA,EAAImE,EAAKlE,OAAQD,IAC/B,IAAK,IAAIkB,EAAI,EAAGA,EAAIiD,EAAKnE,GAAGC,OAAQiB,IAC9BiD,EAAKnE,GAAGkB,GAAG5C,OAAS6F,EAAKnE,GAAGkB,GAAG7C,UACxBgB,KAAK+B,OAAO,GAAK,IAC1B+C,EAAKnE,GAAGkB,GAAG3C,QAAS,EACpB6D,SAASC,eAAT,eAAgCrC,EAAhC,YAAqCkB,IAAK1C,UAAY,aAEtD2F,EAAKnE,GAAGkB,GAAG3C,QAAS,GAK1B6F,GAAQ,kBAAMD,OAkDR,4BAEF,qBAAK3F,UAAU,SAAf,SACE,wBAAQmH,QAASR,EAAjB,qBAEF,qBAAK3G,UAAU,SAAf,SACE,wBAAQmH,QArDhB,WACOlC,GAAaC,IAAUM,IAG5BA,GAAc,EACdI,GAAQ,kBAAMzC,EAAMwC,MACpBjB,YAAW,WACTc,GAAc,IACb,KAoBHD,GAAa,IAyBP,mDAKHuB,MC5XQU,EARH,WACV,OACE,8BACE,cAAC,EAAD,OCFNC,IAASC,OACP,cAAC,EAAD,IAEA9D,SAASC,eAAe,W","file":"static/js/main.b353fac3.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  //console.log(props.isStart);\r\n  const classes = props.isStart\r\n    ? \"node-start\"\r\n    : props.isEnd\r\n    ? \"node-end\"\r\n    : props.isWall\r\n    ? \"wall\"\r\n    : \"\";\r\n  return (\r\n    <button\r\n      className={`Node ${classes}`}\r\n      id={`node-${props.row}-${props.col}`}\r\n      onMouseOver={(x, y) => props.OnEnter(props.row, props.col)}\r\n      onMouseDown={(x, y) => props.OnDown(props.row, props.col)}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","function dijkstra(startNode, endNode) {\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n    visitedNodes.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"no path\" };\r\n}\r\n\r\nfunction heuristic(a, b) {\r\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n  //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\r\n  return d;\r\n}\r\n\r\nexport default dijkstra;\r\n","function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\n\r\nvar toV = [];\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd && !grid[i][j].isWall) {\r\n            document.getElementById(`node-${i}-${j}`).className = \"Node\";\r\n          }\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n            if (!grid[i][j].isStart && !grid[i][j].IsEnd && grid[i][j].isWall) {\r\n              document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\r\n            }\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    let xFall = (rand.x + 1 + current.x + 1) / 2 - 1;\r\n    let yFall = (rand.y + 1 + current.y + 1) / 2 - 1;\r\n    grid[xFall][yFall].isWall = false;\r\n\r\n    toV.push([xFall, yFall]);\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  for (let i = 0; i < toV.length; i++) {\r\n    let x = toV[i][0];\r\n    let y = toV[i][1];\r\n    if (!grid[x][y].isStart && !grid[x][y].isEnd && !grid[x][y].isWall) {\r\n      setTimeout(() => {\r\n        document.getElementById(`node-${x}-${y}`).className = \"Node\";\r\n      }, i * 30);\r\n    }\r\n  }\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Node from \"./Node.js\";\r\nimport \"./Pathfind.css\";\r\nimport dijkstra from \"../Algorithms/dijkstras.js\";\r\nimport Rmaze from \"../Algorithms/Prims Algorithm.js\";\r\n\r\nconst rows = Math.round(window.innerHeight / 34);\r\nconst cols = Math.round(window.innerWidth / 27);\r\n\r\nlet hasStart = true;\r\nlet hasEnd = true;\r\nlet nodeStartRow = 2;\r\nlet nodeStartCol = 2;\r\nlet nodeEndRow = rows - 3;\r\nlet nodeEndCol = cols - 3;\r\nlet visualized = false;\r\nlet visualizing = false;\r\n\r\nconst Pathfind = () => {\r\n  const [Grid, setGrid] = useState([]);\r\n\r\n  useEffect(() => {\r\n    initializeGrid();\r\n  }, []);\r\n\r\n  const createSpot = (Grid) => {\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        Grid[i][j] = new Spot(i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  const initializeGrid = () => {\r\n    const Grid1 = new Array(rows);\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      Grid1[i] = new Array(cols);\r\n    }\r\n    createSpot(Grid1);\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  function Spot(i, j) {\r\n    this.x = i;\r\n    this.y = j;\r\n    this.f = 0;\r\n    this.h = 0;\r\n    this.g = 0;\r\n    this.mazeStatus = undefined;\r\n    this.wallNeighbors = [];\r\n    this.isWall = false;\r\n    this.connections = [];\r\n    this.addWallNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n\r\n      if (i > 1) {\r\n        this.wallNeighbors.push(grid[i - 2][j]);\r\n      }\r\n      if (i < rows - 2) {\r\n        this.wallNeighbors.push(grid[i + 2][j]);\r\n      }\r\n      if (j > 1) {\r\n        this.wallNeighbors.push(grid[i][j - 2]);\r\n      }\r\n      if (j < cols - 2) {\r\n        this.wallNeighbors.push(grid[i][j + 2]);\r\n      }\r\n    };\r\n    this.inTransition = false;\r\n    this.visited = false;\r\n    this.isStart = this.x === nodeStartRow && this.y === nodeStartCol;\r\n    this.isEnd = this.x === nodeEndRow && this.y === nodeEndCol;\r\n    this.neighbors = [];\r\n    this.previous = undefined;\r\n    this.addNeighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n      let rows = grid.length;\r\n      let cols = grid[1].length;\r\n\r\n      if (i > 0) {\r\n        this.neighbors.push(grid[i - 1][j]);\r\n      }\r\n      if (i < rows - 1) {\r\n        this.neighbors.push(grid[i + 1][j]);\r\n      }\r\n      if (j > 0) {\r\n        this.neighbors.push(grid[i][j - 1]);\r\n      }\r\n      if (j < cols - 1) {\r\n        this.neighbors.push(grid[i][j + 1]);\r\n      }\r\n\r\n      if (i > 0 && j > 0 && !(grid[i - 1][j].isWall && grid[i][j - 1].isWall)) {\r\n        this.neighbors.push(grid[i - 1][j - 1]);\r\n      }\r\n      if (\r\n        j < cols - 1 &&\r\n        i < rows - 1 &&\r\n        grid[i + 1][j].isWall == false &&\r\n        grid[i][j + 1].isWall == false\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j < cols - 1 &&\r\n        i > 0 &&\r\n        !(grid[i - 1][j].isWall && grid[i][j + 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i - 1][j + 1]);\r\n      }\r\n\r\n      if (\r\n        j > 0 &&\r\n        i < rows - 1 &&\r\n        !(grid[i + 1][j].isWall && grid[i][j - 1].isWall)\r\n      ) {\r\n        this.neighbors.push(grid[i + 1][j - 1]);\r\n      }\r\n    };\r\n  }\r\n\r\n  const addNeighbors = (grid) => {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        grid[i][j].addNeighbors(grid);\r\n      }\r\n    }\r\n  };\r\n\r\n  const [isDown, setDown] = useState(false);\r\n\r\n  const OnDown = (x, y) => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n    setDown(() => true);\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const OnUp = () => {\r\n    setDown(() => false);\r\n  };\r\n\r\n  const OnEnter = (x, y) => {\r\n    if (!isDown || Grid[x][y].inTransition == true) {\r\n      return;\r\n    }\r\n\r\n    wallUp(x, y);\r\n  };\r\n\r\n  const Reset = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        const node = Grid[i][j];\r\n        node.isWall = false;\r\n        node.neighbors = [];\r\n        node.class = node.isStart\r\n          ? \"node-start\"\r\n          : node.isEnd\r\n          ? \"node-end\"\r\n          : node.isWall\r\n          ? \"wall\"\r\n          : \"\";\r\n        document.getElementById(\r\n          `node-${node.x}-${node.y}`\r\n        ).className = `Node ${node.class}`;\r\n        node.f = 0;\r\n        node.h = 0;\r\n        node.g = 0;\r\n        node.visited = false;\r\n        node.neighbors = [];\r\n        node.previous = undefined;\r\n      }\r\n    }\r\n\r\n    visualized = false;\r\n    setGrid(() => Grid);\r\n  };\r\n  const wallUp = (x, y) => {\r\n    if (visualized) {\r\n      Reset();\r\n    }\r\n    Grid[x][y].inTransition = true;\r\n    setTimeout(() => {\r\n      Grid[x][y].inTransition = false;\r\n    }, 400);\r\n    let Grid1 = [...Grid];\r\n\r\n    if (!hasStart && !Grid1[x][y].isEnd) {\r\n      nodeStartRow = x;\r\n      nodeStartCol = y;\r\n      hasStart = true;\r\n      Grid1[x][y].isStart = true;\r\n    } else if (!hasEnd && !Grid1[x][y].isStart) {\r\n      nodeEndRow = x;\r\n      nodeEndCol = y;\r\n      hasEnd = true;\r\n      Grid1[x][y].isEnd = true;\r\n    } else if (Grid1[x][y].isEnd || Grid1[x][y].isStart || Grid1[x][y].isWall) {\r\n      if (Grid1[x][y].isEnd) {\r\n        nodeEndRow = null;\r\n        nodeEndCol = null;\r\n        hasEnd = false;\r\n        Grid1[x][y].isEnd = false;\r\n      }\r\n      if (Grid1[x][y].isStart) {\r\n        nodeStartRow = null;\r\n        nodeStartCol = null;\r\n        hasStart = false;\r\n        Grid1[x][y].isStart = false;\r\n      }\r\n      if (Grid1[x][y].isWall) {\r\n        Grid1[x][y].isWall = false;\r\n      }\r\n    } else {\r\n      Grid1[x][y].isWall = true;\r\n    }\r\n\r\n    setGrid(() => Grid1);\r\n  };\r\n\r\n  const gridwithNode = (\r\n    <div onMouseUp={() => OnUp()}>\r\n      {Grid.map((row, rowIndex) => {\r\n        return (\r\n          <div key={rowIndex} className=\"rowWrapper\">\r\n            {row.map((col, colIndex) => {\r\n              const { isStart, isEnd, isWall } = col;\r\n              return (\r\n                <Node\r\n                  key={colIndex}\r\n                  isStart={isStart}\r\n                  isEnd={isEnd}\r\n                  row={rowIndex}\r\n                  col={colIndex}\r\n                  OnEnter={OnEnter}\r\n                  OnDown={OnDown}\r\n                  isWall={isWall}\r\n                  OnUp={OnUp}\r\n                />\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  const shortestPath = (shortestPathNodes, startNode, endNode) => {\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPathNodes[i];\r\n        if (node !== startNode && node !== endNode) {\r\n          document.getElementById(`node-${node.x}-${node.y}`).className =\r\n            \"Node node-shortest\";\r\n        }\r\n      }, 5 * i);\r\n    }\r\n  };\r\n\r\n  function visualizePath() {\r\n    if (!hasStart || !hasEnd || visualizing) {\r\n      return;\r\n    }\r\n    if (visualized) {\r\n      Reset();\r\n      return;\r\n    }\r\n    addNeighbors(Grid);\r\n    setGrid(() => Grid);\r\n\r\n    const startNode = Grid[nodeStartRow][nodeStartCol];\r\n    const endNode = Grid[nodeEndRow][nodeEndCol];\r\n\r\n    let path = dijkstra(startNode, endNode);\r\n\r\n    let Path = path.path;\r\n\r\n    let Visited = path.visitedNodes;\r\n\r\n    visualizing = true;\r\n\r\n    for (let i = 0; i <= Visited.length; i++) {\r\n      if (i === Visited.length) {\r\n        setTimeout(() => {\r\n          shortestPath(Path, startNode, endNode);\r\n          visualizing = false;\r\n        }, 16 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = Visited[i];\r\n          if (node !== startNode && node !== endNode) {\r\n            document.getElementById(`node-${node.x}-${node.y}`).className =\r\n              \"Node node-visited\";\r\n          }\r\n        }, 15 * i);\r\n      }\r\n    }\r\n    visualized = true;\r\n  }\r\n\r\n  const randomWalls = () => {\r\n    if (visualizing) {\r\n      return;\r\n    }\r\n\r\n    Reset();\r\n\r\n    for (let i = 0; i < Grid.length; i++) {\r\n      for (let j = 0; j < Grid[i].length; j++) {\r\n        if (Grid[i][j].isEnd || Grid[i][j].isStart) {\r\n        } else if (Math.random(1) < 0.2) {\r\n          Grid[i][j].isWall = true;\r\n          document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\r\n        } else {\r\n          Grid[i][j].isWall = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    setGrid(() => Grid);\r\n  };\r\n\r\n  function generateMaze() {\r\n    if (!hasStart || !hasEnd || visualizing) {\r\n      return;\r\n    }\r\n    visualizing = true;\r\n    setGrid(() => Rmaze(Grid));\r\n    setTimeout(() => {\r\n      visualizing = false;\r\n    }, 6000);\r\n    // for (let i = 0; i < Grid.length; i++) {\r\n    //   setTimeout(() => {\r\n    //     for (let j = 0; j < Grid[i].length; j++) {\r\n    //       setTimeout(() => {\r\n    //         const node = Grid[i][j];\r\n    //         if (!node.isStart && !node.IsEnd && node.isWall) {\r\n    //           document.getElementById(`node-${node.x}-${node.y}`).className =\r\n    //             \"Node wall\";\r\n    //         } else if (!node.isStart && !node.isEnd && !node.isWall) {\r\n    //           document.getElementById(`node-${node.x}-${node.y}`).className =\r\n    //             \"Node\";\r\n    //         }\r\n    //         if (j == Grid[i].length - 1 && i == Grid.length - 1) {\r\n    //           visualizing = false;\r\n    //         }\r\n    //       }, 0 * j);\r\n    //     }\r\n    //   }, 0 * i);\r\n    // }\r\n    visualized = false;\r\n  }\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"header\">\r\n        <h1 className=\"title\">Pathfinding Visualizer</h1>\r\n      </div>\r\n      <div className=\"header\">\r\n        <p>\r\n          click and drag to create walls - replace start and end nodes with\r\n          click\r\n        </p>\r\n      </div>\r\n      <div className=\"row\">\r\n        <div className=\"col-sm\">\r\n          <button onClick={visualizePath}>Vizualize Path (A*)</button>\r\n        </div>\r\n\r\n        <div className=\"col-sm\">\r\n          <button onClick={randomWalls}>Random Walls</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={Reset}>Reset</button>\r\n        </div>\r\n        <div className=\"col-sm\">\r\n          <button onClick={generateMaze}>\r\n            Generate Maze (Prim's Algorithm)\r\n          </button>\r\n        </div>\r\n      </div>\r\n      {gridwithNode}\r\n    </div>\r\n  );\r\n};\r\nexport default Pathfind;\r\n","import React from \"react\";\r\nimport Pathfind from \"./Components/pathfind.js\";\r\n\r\nconst App = () => {\r\n  return (\r\n    <div>\r\n      <Pathfind />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <App />,\r\n\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}