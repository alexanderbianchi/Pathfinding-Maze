{"ast":null,"code":"function dijkstra(startNode,endNode){var openSet=[];var closedSet=[];var path=[];var visitedNodes=[];openSet.push(startNode);var _loop=function _loop(){var leastIndex=0;for(var i=0;i<openSet.length;i++){if(openSet[i].f<openSet[leastIndex].f){leastIndex=i;}}var current=openSet[leastIndex];visitedNodes.push(current);if(current===endNode){var temp=current;path.push(temp);while(temp.previous){path.push(temp.previous);temp=temp.previous;}return{v:{path:path,visitedNodes:visitedNodes}};}openSet=openSet.filter(function(elt){return elt!==current;});closedSet.push(current);var neighbors=current.neighbors;for(var _i=0;_i<neighbors.length;_i++){var neighbor=neighbors[_i];if(!closedSet.includes(neighbor)&&!neighbor.isWall){var tempG=current.g+1;var newPath=false;if(openSet.includes(neighbor)){if(tempG<neighbor.g){neighbor.g=tempG;newPath=true;}}else{neighbor.g=tempG;newPath=true;openSet.push(neighbor);}if(newPath){neighbor.h=heuristic(neighbor,endNode);neighbor.f=neighbor.h+neighbor.g;neighbor.previous=current;}}}};while(openSet.length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return{path:path,visitedNodes:visitedNodes,error:\"no path\"};}function heuristic(a,b){var d=Math.abs(a.x-b.x)+Math.abs(a.y-b.y);//let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\nreturn d;}export default dijkstra;","map":{"version":3,"sources":["E:/CS Projects/visualizer/src/Algorithms/dijkstras.js"],"names":["dijkstra","startNode","endNode","openSet","closedSet","path","visitedNodes","push","leastIndex","i","length","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","isWall","tempG","g","newPath","h","heuristic","error","a","b","d","Math","abs","x","y"],"mappings":"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","sourcesContent":["function dijkstra(startNode, endNode) {\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n    visitedNodes.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"no path\" };\r\n}\r\n\r\nfunction heuristic(a, b) {\r\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n  //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\r\n  return d;\r\n}\r\n\r\nexport default dijkstra;\r\n"]},"metadata":{},"sourceType":"module"}