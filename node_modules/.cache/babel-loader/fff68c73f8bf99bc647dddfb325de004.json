{"ast":null,"code":"function shuffleArray(array) {\n  if (array.length == 0) {\n    return;\n  }\n\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  return array[0];\n}\n\nfunction getRandomItem(set) {\n  let items = Array.from(set);\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nfunction Rmaze(grid) {\n  const WallSetup = grid => {\n    let uniqueSet = new Set();\n\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (i % 2 == 0 && j % 2 == 0) {\n          grid[i][j].addWallNeighbors(grid);\n          shuffleArray(grid[i][j].wallNeighbors);\n          grid[i][j].isWall = false;\n          document.getElementById(`node-${i}-${j}`).className = \"Node\";\n          uniqueSet.add(grid[i][j]);\n        } else {\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\n            grid[i][j].isWall = true;\n            document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\n          }\n        }\n\n        grid[i][j].mazeStatus = \"unvisited\";\n      }\n    }\n\n    return uniqueSet;\n  };\n\n  let frontier = new Set();\n  let visited = new Set();\n  let start = getRandomItem(WallSetup(grid));\n  frontier.add(start);\n  visited.add(start);\n  let current = start;\n  current.mazeStatus = \"visited\";\n\n  function Recurse(grid) {\n    frontier.delete(current);\n    let curN = current.wallNeighbors;\n\n    for (let i = 0; i < curN.length; i++) {\n      if (curN[i].mazeStatus == \"unvisited\") {\n        frontier.add(curN[i]); //curN[i].connections.push(current);\n      } else if (curN[i].mazeStatus === \"frontier\") {//curN[i].connections.push(current);\n      }\n    }\n\n    if (frontier.size == 0) {\n      return;\n    }\n\n    current = getRandomItem(frontier);\n    visited.add(current);\n    current.mazeStatus = \"visited\";\n    let adj = [];\n\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\n        adj.push(current.wallNeighbors[i]);\n      }\n    }\n\n    let rand = shuffleArray(adj);\n    grid[(rand.x + 1 + current.x + 1) / 2 - 1][(rand.y + 1 + current.y + 1) / 2 - 1].isWall = false; //setTimeout(() => {\n\n    document.getElementById(`node-${(rand.x + 1 + current.x + 1) / 2 - 1}-${(rand.y + 1 + current.y + 1) / 2 - 1}`).className = \"Node\"; //}, 400);\n\n    if (frontier.size > 0) {\n      Recurse(grid);\n    }\n  }\n\n  Recurse(grid);\n  return grid;\n}\n\n_c = Rmaze;\nexport default Rmaze;\n\nvar _c;\n\n$RefreshReg$(_c, \"Rmaze\");","map":{"version":3,"sources":["E:/CS Projects/visualizer/src/Algorithms/Prims Algorithm.js"],"names":["shuffleArray","array","length","i","j","Math","floor","random","temp","getRandomItem","set","items","Array","from","Rmaze","grid","WallSetup","uniqueSet","Set","addWallNeighbors","wallNeighbors","isWall","document","getElementById","className","add","isStart","isEnd","mazeStatus","frontier","visited","start","current","Recurse","delete","curN","size","adj","push","rand","x","y"],"mappings":"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","sourcesContent":["function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n          document.getElementById(`node-${i}-${j}`).className = \"Node\";\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n            document.getElementById(`node-${i}-${j}`).className = \"Node wall\";\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    grid[(rand.x + 1 + current.x + 1) / 2 - 1][\r\n      (rand.y + 1 + current.y + 1) / 2 - 1\r\n    ].isWall = false;\r\n    //setTimeout(() => {\r\n    document.getElementById(\r\n      `node-${(rand.x + 1 + current.x + 1) / 2 - 1}-${\r\n        (rand.y + 1 + current.y + 1) / 2 - 1\r\n      }`\r\n    ).className = \"Node\";\r\n    //}, 400);\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n"]},"metadata":{},"sourceType":"module"}