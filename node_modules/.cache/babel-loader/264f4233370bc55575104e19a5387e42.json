{"ast":null,"code":"function dijkstra(startNode, endNode) {\n  let openSet = [];\n  let closedSet = [];\n  let path = [];\n  let visitedNodes = [];\n  openSet.push(startNode);\n\n  while (openSet.length > 0) {\n    let leastIndex = 0;\n\n    for (let i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[leastIndex].f) {\n        leastIndex = i;\n      }\n    }\n\n    let current = openSet[leastIndex];\n    visitedNodes.push(current);\n\n    if (current === endNode) {\n      let temp = current;\n      path.push(temp);\n\n      while (temp.previous) {\n        path.push(temp.previous);\n        temp = temp.previous;\n      }\n\n      return {\n        path,\n        visitedNodes\n      };\n    }\n\n    openSet = openSet.filter(elt => elt !== current);\n    closedSet.push(current);\n    let neighbors = current.neighbors;\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\n        let tempG = current.g + 1;\n        let newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        }\n\n        if (newPath) {\n          neighbor.h = heuristic(neighbor, endNode);\n          neighbor.f = neighbor.h + neighbor.g;\n          neighbor.previous = current;\n        }\n      }\n    }\n  }\n\n  return {\n    path,\n    visitedNodes,\n    error: \"no path\"\n  };\n}\n\nfunction heuristic(a, b) {\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y); //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\n\n  return d;\n}\n\nexport default dijkstra;","map":{"version":3,"sources":["E:/CS Projects/visualizer/src/Algorithms/dijkstras.js"],"names":["dijkstra","startNode","endNode","openSet","closedSet","path","visitedNodes","push","length","leastIndex","i","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","isWall","tempG","g","newPath","h","heuristic","error","a","b","d","Math","abs","x","y"],"mappings":"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","sourcesContent":["function dijkstra(startNode, endNode) {\r\n  let openSet = [];\r\n  let closedSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n    visitedNodes.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"no path\" };\r\n}\r\n\r\nfunction heuristic(a, b) {\r\n  let d = Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n  //let d = (b.y - a.y) / (b.x - a.x); //Alternative hueristic\r\n  return d;\r\n}\r\n\r\nexport default dijkstra;\r\n"]},"metadata":{},"sourceType":"module"}