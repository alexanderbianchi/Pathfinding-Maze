{"ast":null,"code":"function shuffleArray(array) {\n  if (array.length == 0) {\n    return;\n  }\n\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  return array[0];\n}\n\nfunction getRandomItem(set) {\n  let items = Array.from(set);\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nfunction Rmaze(grid) {\n  const WallSetup = grid => {\n    let uniqueSet = new Set();\n\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        let node = grid[i][j];\n\n        if (i % 2 == 0 && j % 2 == 0) {\n          grid[i][j].addWallNeighbors(grid);\n          shuffleArray(grid[i][j].wallNeighbors);\n          grid[i][j].isWall = false;\n\n          if (!node.isStart && !node.IsEnd && node.isWall) {\n            document.getElementById(`node-${node.x}-${node.y}`).className = \"Node\";\n          }\n\n          uniqueSet.add(grid[i][j]);\n        } else {\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\n            grid[i][j].isWall = true;\n\n            if (!node.isStart && !node.IsEnd && node.isWall) {\n              document.getElementById(`node-${node.x}-${node.y}`).className = \"Node wall\";\n            }\n          }\n        }\n\n        grid[i][j].mazeStatus = \"unvisited\";\n      }\n    }\n\n    return uniqueSet;\n  };\n\n  let frontier = new Set();\n  let visited = new Set();\n  let start = getRandomItem(WallSetup(grid));\n  frontier.add(start);\n  visited.add(start);\n  let current = start;\n  current.mazeStatus = \"visited\";\n\n  function Recurse(grid) {\n    frontier.delete(current);\n    let curN = current.wallNeighbors;\n\n    for (let i = 0; i < curN.length; i++) {\n      if (curN[i].mazeStatus == \"unvisited\") {\n        frontier.add(curN[i]); //curN[i].connections.push(current);\n      } else if (curN[i].mazeStatus === \"frontier\") {//curN[i].connections.push(current);\n      }\n    }\n\n    if (frontier.size == 0) {\n      return;\n    }\n\n    current = getRandomItem(frontier);\n    visited.add(current);\n    current.mazeStatus = \"visited\";\n    let adj = [];\n\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\n        adj.push(current.wallNeighbors[i]);\n      }\n    }\n\n    let rand = shuffleArray(adj);\n    let x = (rand.x + 1 + current.x + 1) / 2 - 1;\n    let y = (rand.y + 1 + current.y + 1) / 2 - 1;\n    grid[x][y].isWall = false;\n\n    if (frontier.size > 0) {\n      Recurse(grid);\n    }\n  }\n\n  Recurse(grid);\n  return grid;\n}\n\n_c = Rmaze;\nexport default Rmaze;\n\nvar _c;\n\n$RefreshReg$(_c, \"Rmaze\");","map":{"version":3,"sources":["E:/CS Projects/visualizer/src/Algorithms/Prims Algorithm.js"],"names":["shuffleArray","array","length","i","j","Math","floor","random","temp","getRandomItem","set","items","Array","from","Rmaze","grid","WallSetup","uniqueSet","Set","node","addWallNeighbors","wallNeighbors","isWall","isStart","IsEnd","document","getElementById","x","y","className","add","isEnd","mazeStatus","frontier","visited","start","current","Recurse","delete","curN","size","adj","push","rand"],"mappings":"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","sourcesContent":["function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        let node = grid[i][j];\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n\r\n          if (!node.isStart && !node.IsEnd && node.isWall) {\r\n            document.getElementById(`node-${node.x}-${node.y}`).className =\r\n              \"Node\";\r\n          }\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n\r\n            if (!node.isStart && !node.IsEnd && node.isWall) {\r\n              document.getElementById(`node-${node.x}-${node.y}`).className =\r\n                \"Node wall\";\r\n            }\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    let x = (rand.x + 1 + current.x + 1) / 2 - 1;\r\n    let y = (rand.y + 1 + current.y + 1) / 2 - 1;\r\n    grid[x][y].isWall = false;\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n"]},"metadata":{},"sourceType":"module"}