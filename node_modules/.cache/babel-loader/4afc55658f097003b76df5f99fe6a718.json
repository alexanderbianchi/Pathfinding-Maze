{"ast":null,"code":"function shuffleArray(array) {\n  if (array.length == 0) {\n    return;\n  }\n\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  return array[0];\n}\n\nfunction getRandomItem(set) {\n  let items = Array.from(set);\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nvar toV = [];\n\nfunction Rmaze(grid) {\n  const WallSetup = grid => {\n    let uniqueSet = new Set();\n\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (i % 2 == 0 && j % 2 == 0) {\n          grid[i][j].addWallNeighbors(grid);\n          shuffleArray(grid[i][j].wallNeighbors);\n          grid[i][j].isWall = false;\n\n          if (!node.isStart && !node.isEnd && !node.isWall) {\n            document.getElementById(`node-${i}-${j}`).className = \"Node\";\n          }\n\n          uniqueSet.add(grid[i][j]);\n        } else {\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\n            grid[i][j].isWall = true;\n\n            if (!node.isStart && !node.IsEnd && node.isWall) {\n              document.getElementById(`node-${i}-${j}`).className = \"Node wall-noAnimate\";\n            }\n          }\n        }\n\n        grid[i][j].mazeStatus = \"unvisited\";\n      }\n    }\n\n    return uniqueSet;\n  };\n\n  let frontier = new Set();\n  let visited = new Set();\n  let start = getRandomItem(WallSetup(grid));\n  frontier.add(start);\n  visited.add(start);\n  let current = start;\n  current.mazeStatus = \"visited\";\n\n  function Recurse(grid) {\n    frontier.delete(current);\n    let curN = current.wallNeighbors;\n\n    for (let i = 0; i < curN.length; i++) {\n      if (curN[i].mazeStatus == \"unvisited\") {\n        frontier.add(curN[i]); //curN[i].connections.push(current);\n      } else if (curN[i].mazeStatus === \"frontier\") {//curN[i].connections.push(current);\n      }\n    }\n\n    if (frontier.size == 0) {\n      return;\n    }\n\n    current = getRandomItem(frontier);\n    visited.add(current);\n    current.mazeStatus = \"visited\";\n    let adj = [];\n\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\n        adj.push(current.wallNeighbors[i]);\n      }\n    }\n\n    let rand = shuffleArray(adj);\n    let xFall = (rand.x + 1 + current.x + 1) / 2 - 1;\n    let yFall = (rand.y + 1 + current.y + 1) / 2 - 1;\n    grid[xFall][yFall].isWall = false;\n    toV.push([xFall, yFall]);\n\n    if (frontier.size > 0) {\n      Recurse(grid);\n    }\n  }\n\n  Recurse(grid);\n\n  for (let i = 0; i < toV.length; i++) {\n    let x = toV[i][0];\n    let y = toV[i][1];\n\n    if (!node.isStart && !node.isEnd && !node.isWall) {\n      setTimeout(() => {\n        document.getElementById(`node-${x}-${y}`).className = \"Node\";\n      }, i * 30);\n    }\n  }\n\n  return grid;\n}\n\n_c = Rmaze;\nexport default Rmaze;\n\nvar _c;\n\n$RefreshReg$(_c, \"Rmaze\");","map":{"version":3,"sources":["E:/CS Projects/visualizer/src/Algorithms/Prims Algorithm.js"],"names":["shuffleArray","array","length","i","j","Math","floor","random","temp","getRandomItem","set","items","Array","from","toV","Rmaze","grid","WallSetup","uniqueSet","Set","addWallNeighbors","wallNeighbors","isWall","node","isStart","isEnd","document","getElementById","className","add","IsEnd","mazeStatus","frontier","visited","start","current","Recurse","delete","curN","size","adj","push","rand","xFall","x","yFall","y","setTimeout"],"mappings":"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","sourcesContent":["function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\n\r\nvar toV = [];\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n          if (!node.isStart && !node.isEnd && !node.isWall) {\r\n            document.getElementById(`node-${i}-${j}`).className = \"Node\";\r\n          }\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n            if (!node.isStart && !node.IsEnd && node.isWall) {\r\n              document.getElementById(`node-${i}-${j}`).className =\r\n                \"Node wall-noAnimate\";\r\n            }\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    let xFall = (rand.x + 1 + current.x + 1) / 2 - 1;\r\n    let yFall = (rand.y + 1 + current.y + 1) / 2 - 1;\r\n    grid[xFall][yFall].isWall = false;\r\n\r\n    toV.push([xFall, yFall]);\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  for (let i = 0; i < toV.length; i++) {\r\n    let x = toV[i][0];\r\n    let y = toV[i][1];\r\n    if (!node.isStart && !node.isEnd && !node.isWall) {\r\n      setTimeout(() => {\r\n        document.getElementById(`node-${x}-${y}`).className = \"Node\";\r\n      }, i * 30);\r\n    }\r\n  }\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n"]},"metadata":{},"sourceType":"module"}