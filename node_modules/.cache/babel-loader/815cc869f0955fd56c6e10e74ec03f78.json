{"ast":null,"code":"function shuffleArray(array) {\n  if (array.length == 0) {\n    return;\n  }\n\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  return array[0];\n}\n\nfunction getRandomItem(set) {\n  let items = Array.from(set);\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nfunction Rmaze(grid) {\n  const WallSetup = grid => {\n    let uniqueSet = new Set();\n\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (i % 2 == 0 && j % 2 == 0) {\n          grid[i][j].addWallNeighbors(grid);\n          shuffleArray(grid[i][j].wallNeighbors);\n          grid[i][j].isWall = false;\n          uniqueSet.add(grid[i][j]);\n        } else {\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\n            grid[i][j].isWall = true;\n          }\n        }\n\n        grid[i][j].mazeStatus = \"unvisited\";\n      }\n    }\n\n    return uniqueSet;\n  };\n\n  let frontier = new Set();\n  let visited = new Set();\n  let start = getRandomItem(WallSetup(grid));\n  frontier.add(start);\n  visited.add(start);\n  let current = start;\n  current.mazeStatus = \"visited\";\n\n  function Recurse(grid) {\n    frontier.delete(current);\n    let curN = current.wallNeighbors;\n\n    for (let i = 0; i < curN.length; i++) {\n      if (curN[i].mazeStatus == \"unvisited\") {\n        frontier.add(curN[i]); //curN[i].connections.push(current);\n      } else if (curN[i].mazeStatus === \"frontier\") {//curN[i].connections.push(current);\n      }\n    }\n\n    if (frontier.size == 0) {\n      return;\n    }\n\n    current = getRandomItem(frontier);\n    visited.add(current);\n    current.mazeStatus = \"visited\";\n    let adj = [];\n\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\n        adj.push(current.wallNeighbors[i]);\n      }\n    }\n\n    let rand = shuffleArray(adj);\n    let x = (rand.x + 1 + current.x + 1) / 2 - 1;\n    let y = (rand.y + 1 + current.y + 1) / 2 - 1;\n    grid[x][y].isWall = false;\n\n    if (frontier.size > 0) {\n      Recurse(grid);\n    }\n  }\n\n  Recurse(grid);\n  return grid;\n}\n\n_c = Rmaze;\nexport default Rmaze;\n\nvar _c;\n\n$RefreshReg$(_c, \"Rmaze\");","map":{"version":3,"sources":["E:/CS Projects/visualizer/src/Algorithms/Prims Algorithm.js"],"names":["shuffleArray","array","length","i","j","Math","floor","random","temp","getRandomItem","set","items","Array","from","Rmaze","grid","WallSetup","uniqueSet","Set","addWallNeighbors","wallNeighbors","isWall","add","isStart","isEnd","mazeStatus","frontier","visited","start","current","Recurse","delete","curN","size","adj","push","rand","x","y"],"mappings":"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","sourcesContent":["function shuffleArray(array) {\r\n  if (array.length == 0) {\r\n    return;\r\n  }\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n\r\n  return array[0];\r\n}\r\nfunction getRandomItem(set) {\r\n  let items = Array.from(set);\r\n  return items[Math.floor(Math.random() * items.length)];\r\n}\r\nfunction Rmaze(grid) {\r\n  const WallSetup = (grid) => {\r\n    let uniqueSet = new Set();\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i % 2 == 0 && j % 2 == 0) {\r\n          grid[i][j].addWallNeighbors(grid);\r\n\r\n          shuffleArray(grid[i][j].wallNeighbors);\r\n\r\n          grid[i][j].isWall = false;\r\n          uniqueSet.add(grid[i][j]);\r\n        } else {\r\n          if (!grid[i][j].isStart && !grid[i][j].isEnd) {\r\n            grid[i][j].isWall = true;\r\n          }\r\n        }\r\n        grid[i][j].mazeStatus = \"unvisited\";\r\n      }\r\n    }\r\n    return uniqueSet;\r\n  };\r\n  let frontier = new Set();\r\n  let visited = new Set();\r\n\r\n  let start = getRandomItem(WallSetup(grid));\r\n  frontier.add(start);\r\n  visited.add(start);\r\n  let current = start;\r\n  current.mazeStatus = \"visited\";\r\n\r\n  function Recurse(grid) {\r\n    frontier.delete(current);\r\n\r\n    let curN = current.wallNeighbors;\r\n\r\n    for (let i = 0; i < curN.length; i++) {\r\n      if (curN[i].mazeStatus == \"unvisited\") {\r\n        frontier.add(curN[i]);\r\n        //curN[i].connections.push(current);\r\n      } else if (curN[i].mazeStatus === \"frontier\") {\r\n        //curN[i].connections.push(current);\r\n      }\r\n    }\r\n\r\n    if (frontier.size == 0) {\r\n      return;\r\n    }\r\n    current = getRandomItem(frontier);\r\n    visited.add(current);\r\n    current.mazeStatus = \"visited\";\r\n\r\n    let adj = [];\r\n    for (let i = 0; i < current.wallNeighbors.length; i++) {\r\n      if (current.wallNeighbors[i].mazeStatus == \"visited\") {\r\n        adj.push(current.wallNeighbors[i]);\r\n      }\r\n    }\r\n    let rand = shuffleArray(adj);\r\n\r\n    let x = (rand.x + 1 + current.x + 1) / 2 - 1;\r\n    let y = (rand.y + 1 + current.y + 1) / 2 - 1;\r\n    grid[x][y].isWall = false;\r\n\r\n    if (frontier.size > 0) {\r\n      Recurse(grid);\r\n    }\r\n  }\r\n  Recurse(grid);\r\n\r\n  return grid;\r\n}\r\nexport default Rmaze;\r\n"]},"metadata":{},"sourceType":"module"}